package com.astro.storm.data.model

/**
 * Complete Vedic astrology chart
 */
data class VedicChart(
    val birthData: BirthData,
    val julianDay: Double,
    val ayanamsa: Double,
    val ayanamsaName: String,
    val ascendant: Double,
    val midheaven: Double,
    val planetPositions: List<PlanetPosition>,
    val houseCusps: List<Double>,
    val houseSystem: HouseSystem,
    val calculationTime: Long = System.currentTimeMillis()
) {
    val planetsByHouse: Map<Int, List<PlanetPosition>> by lazy {
        planetPositions.groupBy { it.house }
    }

    fun toPlainText(): String {
        return buildString {
            appendLine("═══════════════════════════════════════════════════════════")
            appendLine("                  VEDIC BIRTH CHART")
            appendLine("═══════════════════════════════════════════════════════════")
            appendLine()

            appendLine("BIRTH INFORMATION")
            appendLine("─────────────────────────────────────────────────────────")
            appendLine("Name          : ${birthData.name}")
            appendLine("Date & Time   : ${birthData.dateTime}")
            appendLine("Location      : ${birthData.location}")
            appendLine("Coordinates   : ${formatCoordinate(birthData.latitude, true)}, ${formatCoordinate(birthData.longitude, false)}")
            appendLine("Timezone      : ${birthData.timezone}")
            appendLine()

            appendLine("ASTRONOMICAL DATA")
            appendLine("─────────────────────────────────────────────────────────")
            appendLine("Julian Day    : ${String.format("%.6f", julianDay)}")
            appendLine("Ayanamsa      : $ayanamsaName")
            appendLine("Ayanamsa Value: ${formatDegree(ayanamsa)}")
            appendLine("Ascendant     : ${formatDegree(ascendant)} (${ZodiacSign.fromLongitude(ascendant).displayName})")
            appendLine("Midheaven     : ${formatDegree(midheaven)} (${ZodiacSign.fromLongitude(midheaven).displayName})")
            appendLine("House System  : ${houseSystem.displayName}")
            appendLine()

            appendLine("PLANETARY POSITIONS (Sidereal)")
            appendLine("─────────────────────────────────────────────────────────")
            planetPositions.forEach { position ->
                appendLine(position.toLLMString())
            }
            appendLine()

            appendLine("HOUSE CUSPS")
            appendLine("─────────────────────────────────────────────────────────")
            houseCusps.forEachIndexed { index, cusp ->
                val sign = ZodiacSign.fromLongitude(cusp)
                appendLine("House ${(index + 1).toString().padStart(2)}: ${formatDegree(cusp)} (${sign.displayName})")
            }
            appendLine()

            appendLine("NAKSHATRA DETAILS")
            appendLine("─────────────────────────────────────────────────────────")
            planetPositions.forEach { position ->
                appendLine("${position.planet.displayName.padEnd(10)}: ${position.nakshatra.displayName.padEnd(20)} Pada ${position.nakshatraPada} | Ruler: ${position.nakshatra.ruler.displayName}")
            }
            appendLine()

            appendLine("═══════════════════════════════════════════════════════════")
            appendLine("Generated by AstroStorm - Ultra-Precision Vedic Astrology")
            appendLine("Calculation Engine: Swiss Ephemeris (JPL Mode)")
            appendLine("═══════════════════════════════════════════════════════════")
        }
    }

    private fun formatCoordinate(value: Double, isLatitude: Boolean): String {
        val abs = kotlin.math.abs(value)
        val degrees = abs.toInt()
        val minutes = ((abs - degrees) * 60).toInt()
        val seconds = ((((abs - degrees) * 60) - minutes) * 60).toInt()
        val direction = if (isLatitude) {
            if (value >= 0) "N" else "S"
        } else {
            if (value >= 0) "E" else "W"
        }
        return "$degrees° $minutes' $seconds\" $direction"
    }

    private fun formatDegree(degree: Double): String {
        val normalizedDegree = (degree % 360.0 + 360.0) % 360.0
        val deg = normalizedDegree.toInt()
        val min = ((normalizedDegree - deg) * 60).toInt()
        val sec = ((((normalizedDegree - deg) * 60) - min) * 60).toInt()
        return "$deg° $min' $sec\""
    }
}
